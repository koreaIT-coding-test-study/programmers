
# Hash Table

### Hashing이란
![image](https://user-images.githubusercontent.com/67637716/178504640-a70e7185-cbd6-47de-9fe1-a05990ab065c.png)  
임의의 길이의 값(문자열, 파일 등 데이터)을 해싱 함수(Hash Function)를 사용하여 고정된 크기의 값(정수) 으로 변환하는 작업.  
해싱을 사용하여 데이터를 저장하는 자료구조를 해시 테이블(Hash Table)이라고 하며,  
배열에 비해 굉장히 빠른 속도로 탐색, 삽입, 삭제가 가능하다.  

### HashTable
해시 함수를 사용하여 변환한 값을 색인(index)으로 삼아 key와 value를 저장하는 자료구조를 말함.  


### Direct Addressing Table
![image](https://user-images.githubusercontent.com/67637716/178505785-d4f88355-c3e8-4790-88ab-8d11d004b660.png)  
key-value쌍의 데이터를 배열에 저장.  
key값을 직접적으로 배열의 인덱스로 사용하는 방법.  
똑같은 키 값이 존재하지 않는다고 가정하면, 삽입 시에는 각 키마다 자신의 공간이 존재하므로 그 위치에 저장을 하면 되고,  
삭제 시에는 해당 키의 위치에 NULL값을 넣어 주면 됨.  
탐색 시에는 해당 키의 위치를 그냥 찾아가서 참조하면 되므로, 찾고자 하는 데이터의 key만 알고 있으면 
즉시 위치를 찾는 것이 가능해지므로 탐색, 저장, 삭제, 갱신은 모두 O(1)으로 매운 빠른 속도로 처리.  
<br>
단점으론 key값의 최대 크기만큼 배열이 할당 되기 때문에, 크기는 매우 큰데 저장하고자 하는 데이터가 적다면 공간을 많이 낭비할 수 있다는 단점이 있음.  

### Hash Table
![image](https://user-images.githubusercontent.com/67637716/178507087-61ea91c7-179b-44ad-a289-226f16551676.png)  
Direct Addressing Table과는 다르게 key값을 함수를 이용해 계산을 수행 후, 그 결과 값을 배열의 인덱스로 사용하여 저장하는 방식.  
여기서 key값을 계산하는 함수를 `해쉬 함수`라고 부르며 해쉬 함수는 key값을 바다 0 부터 배열크기-1 사이의 값을 출력한다.  
이 때 k값이 h(k)로 해쉬되었다고 하며, h(k)는 k의 해쉬값이라고 한다.  
해쉬 테이블은 key값의 크기에 테이블의 크기가 좌우되는 것이 아니고 h(k)만큼의 공간에 저장되기 때문에  
Direct Addressing Table에 비해 공간 낭비가 매우 적다.  

![image](https://user-images.githubusercontent.com/67637716/178508979-1ec3f93d-ae1c-458b-a84f-3049d086279b.png)  
 해시테이블(Hash Table, Hash Map이라고도 불림.)은 Key와 Value를 갖는 자료구조이다.  
 John Smith라는 사람의 전화번호를 찾는 과정을 가정했을 때,  
 해시함수(Hash Function)의 입력값은 "John Smith"이고 출력값은 "01"이다.  
 그리고 색인이 "01"인 bucket에서 "521-8976"을 찾는다.  



# 충돌(Collusion)
데이터를 Key로 간소화하여 저장한다는 아이디어는 좋지만,  
다른 내용의 데이터가 같은 키를 갖는다면 이러한 상황을 해시 충돌(Hash Collision)이라고 한다.   
같은 키값을 갖는 데이터가 생긴다는 것은, 특정 키의 버켓에 데이터가 집중된다는 뜻이다.  
그래서 너무 많은 해시 충돌은 해시테이블의 성능을 떨어뜨린다.   
<b>해시 함수를 잘 정의하여 해시 충돌을 최소화 하는 것이 성능 개선에 도움이 된다</b>  
그럼에도 해시함수의 입력값은 무한하지만 출력값의 가짓수가 유한하다면 해시 충돌은 반드시 발생한다.  
해시 충돌을 해결하는 방법에는 여러가지가 있다.  

결론적으로 해시 테이블의 중점사항은 충돌을 완화하는 것이며 방법은 두가지이다.  
* 해시 테이블 구조 개선
* 해시 함수 개선

# 해시 테이블 구조 개선
## Chaining (체이닝)
![image](https://user-images.githubusercontent.com/67637716/178510501-c5fffc12-7b9b-4501-bfbb-55e2b3b3e6f6.png)  
체이닝이란 충돌이 발생했을 때 이를 동일한 버킷(Bucket)에 저장하는데 이를 연결리스트 형태로 저장하는 방법을 말한다.  
위 그림을 보면 John Smith 와 Sandra Dee 의 인덱스가 152 로 충돌하게 된 경우인데,  
이 때 Sandra Dee 를 John Smith 뒤에 연결함으로써 충돌을 처리하는 것을 볼 수 있다.  
체이닝을 통해 해시테이블을 구현했을 때의 시간복잡도는 삽입의 경우 연결리스트에 추가하기만 하면 되기 때문에 상수시간인 O(1) 이 걸리지만  
탐색과 삭제의 경우는 최악일 때 키 값의 개수인 K 에 대해 O(K) 가 걸리게 된다.  

## Open Addressing (개방 주소법)
![image](https://user-images.githubusercontent.com/67637716/178511474-f7715058-7c74-4b54-aade-b39fd086c54b.png)  
체이닝의 경우 버켓이 꽉 차더라도 연결리스트로 계속 늘려가기에, 데이터의 주소값은 바뀌지 않는다.  
Open Addressing은 동일한 주소에 다른 데이터가 있을 경우 다른 주소도 이용할 수 있게 하는 기법이다.  
위에서 살펴본 동일한 충돌에 대해서 이번엔 체이닝 방식을 적용하지 않고 그 다음으로 비어있는 주소인 153 에 저장하는 것을 볼 수 있다.  
이러한 원리로 탐색, 삽입, 삭제가 이루어지는데 다음과 같이 동작한다.  

* 삽입: 계산한 해시 값에 대한 인덱스가 이미 차있는 경우 다음 인덱스로 이동하면서 비어있는 곳에 저장한다. 이렇게 비어있는 자리를 탐색하는 것을 탐사(Probing)라고 한다.
* 탐색: 계산한 해시 값에 대한 인덱스부터 검사하며 탐사를 해나가는데 이 때 “삭제” 표시가 있는 부분은 지나간다.
* 삭제: 탐색을 통해 해당 값을 찾고 삭제한 뒤 “삭제” 표시를 한다.  

open addressing 방식은 3가지 방법을 통해서 해시 충돌을 처리한다.  

### 선형 탐사 (Linear Probing)
![image](https://user-images.githubusercontent.com/67637716/178512308-a94a9530-daa5-4a22-af86-d770d90beb6d.png)  
선형탐사는 가장 기본적인 충돌해결기법으로 위에서 설명한 기본적인 동작방식이다.  
선형탐사는 바로 인접한 인덱스에 데이터를 삽입해가기 때문에 데이터가 밀집되는 클러스터링(Clustering) 문제가 발생하고 이로인해 탐색과 삭제가 느려지게 된다.  

### 제곱탐사(Quadratic Probing)
![image](https://user-images.githubusercontent.com/67637716/178512605-38b39112-0f0d-4079-81ea-15cc45482c92.png)  
제곱탐사는 말 그대로 제곱 수(1,2,3...)으로 탐사를 하는 방식으로 선형탐사에 비해 더 폭넓게 탐사하기 때문에 탐색과 삭제에 효율적일 수 있다.  
하지만 이는 초기 해시값이 같을 경우에 탐사하는 역시나 클러스터링 문제가 발생하게 된다.  

### 이중해싱(Double Hashing)
이중해싱은 선형탐사와 제곱탐사에서 발생하는 클러스터링 문제를 모두 피하기 위해 도입된 것이다.  
처음 해시함수로는 해시값을 찾기 위해 사용하고 두번째 해시함수는 충돌이 발생했을 때 탐사폭을 계산하기 위해 사용되는 방식이다.  



![image](https://user-images.githubusercontent.com/67637716/178511974-e826b68d-3991-47f9-8648-573f03b6660f.png)  
 ![image](https://user-images.githubusercontent.com/67637716/178511903-861b7c9c-da93-49bc-9b36-6966f9ebea03.png)  
 
 
 # 해시 함수 개선
 ### 나눗셈법(Division Method)
 아주 간단하게 해시값을 구하는 방법으로 미리 해시 테이블의 크기인 N 을 아는 경우에 사용할 수 있다.  
 해시함수를 적용하고자 하는 값을 N 으로 나눈 나머지를 해시값으로 사용하는 방법이다.  
 ``` java
 h(k)=k mod N
 // N 은 소수(Prime Number)를 사용하는 것이 좋다.
 ```  
 
 ### 곱셈법(Multiplication Method)
 0<A<1 인 A 에 대해서 다음과 같이 구할 수 있다.  
``` java
h(k)=⌊N(kA mod 1)⌋
```  

이외에도 다양한 해시 함수가 있다
 
 

