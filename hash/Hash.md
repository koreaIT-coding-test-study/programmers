# Hash

ArrayList는 내부 인덱스를 이용하여 검색이 한 번에 이루어지기 때문에 빠른 검색 속도를 보장하는 반면 데이터의 추가/삭제 시 많은 데이터가 밀리거나 당겨지기 때문에 많은 시간이 소요된다.

LinkedList는 추가/삭제 시 인근 노드들의 참조 값만 수정해 줌으로써 빠른 처리가 가능하지만 데이터를 검색할 경우 해당 노드를 찾기 위해 순회 검색을 해야하기 때문에 데이터의 수가 많아질 수록 효율이 떨어지는 구조다.

** 이러한 한계를 극복하기 위해서 제시된 방법이 Hash다. **

Hash는 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 빠른 검색속도를 갖는다.
그리고 데이터 추가/삭제시 기존 데이터를 밀어내거나 당기는 작업이 필요없도록 특별한 알고리즘을 이용하여 데이터와 연관된 고유한 숫자를 만들어 낸 뒤 이를 인덱스로 사용한다.

특정 데이터가 저장되는 인덱스를 그 데이터만의 고유한 위치로 정하여서 데이터 추가/삭제시 데이터의 이동이 없도록 만들어진 구조이다.

Hash가 내부적으로 사용하는 배열을 Hash Table 이라고 하며 크기에 따라 성능차이가 날 수 있다.

## Hash Table
key-value 에서 key를 테이블에 저장할 때 key값을 Hash Method를 이용해 계산을 수행한 후, 그 결과값을 배열의 인덱스로 사용하여 저장하는 방식이다. 

여기서 key값을 계산하는 것이 Hash Method 이다.

## Hash Method
Hash는 특별한 알고리즘을 이용하여 데이터의 고유한 숫자값을 만들어 인덱스로 사용한다고 했다. 

이 알고리즘을 구현한 메소드를 Hash Method라고 하며 Hash Method에 의해 반환된 데이터의 고유 숫자값을 HashCode 라고한다.

## Hashing
HashMap과 같이 Hashing을 구현한 컬렉션 클래스에서는 Object 클래스에 정의된 hashCode()를 Hash Method로 사용한다. 

Object 클래스에 정의된 hashCode()는 객체의 주소를 이용하는 알고리즘으로 해시 코드를 만들어내기 때문에 모든 객체에 대해 중복되지 않는 값을 제공한다.

MAP은 key-value로 데이터를 다를 수 있도록 하는 인터페이스이다. 

이 때 key-value의 특징을 기억해보면 key는 중복이 되면 안된다는 것이다. 

중복을 허용하지 않는다는 것은 key를 따로 저장해두고 새로운 key가 추가될 때 key 저장소를 검사해야 한다는 뜻이다. 
